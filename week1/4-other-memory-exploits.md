# Other memory exploits

## Heap overflow

Example:

```C
typedef struct _vulnerable_struct {
    char buff[MAX_LEN];         //character pointer
    int (*cmp)(char*,char*);    // compare function pointer
} vulnerable;

int foo(vulnerable* s, char* one, char* two){
    strcpy( s->buff, one );     // copy one into buff
    strcat( s->buff, two );     // copy two into buff
    return s->cmp( s->buff, "file://foobar" );  // compares buff with foobar file pointer 
}
```

This code only works if the string length of one and two is less then the MAX_LEN of the buffer. Otherwise the compare function pointer will be overwritten.  

This attack also has a couple of variants:

* Overflow into the C++ object vtable
* Overflow into adjacent object (eg: one adjusting a function pointer)
* Overflow heap metadata (use malloc and free to carry out an attack)

## Integer overflow attack

In a language like C, an integer has a maximum value. If that value is exceeded, the variables value will wrap around.  
Example:

```C
void vulnerable(){
    char *response;
    int nresp = packet_get_int(); // Reads form the network
    if (nresp > 0){
        response = malloc(nresp*sizeof(char*)); // Wraps-around
        for(i = 0; i < nresp; i++)
            response[i] = packet_get_string(NULL); // Overflow
    }
}
```

If the adversary has control over the other side of the network, they can send a very large package. Then nresp*sizeof(char*) overflows to become 0. And then it writes to allocated response overflow it.  

Attackers can overflow data to:

* Modify a secret key (to be able to decrypt future messages)
* Modify state variables (to bypass authorization checks)
* Modify interpreted strings (used as part of commands eg: SQL injection)

## Read Overflow

This might leak secret information  

Example:

```C
int main() {
    char buf[100], *p;
    int i, len;
    while(1){
        p = fgets(buf, sizeof(buf), stdin);         // Read integer
        if(p == NULL) return 0;
        len = atoi(p);
        p = fget(buf, sizeof(buf), stdin);          // Read message
        if (p == NULL) return 0;
        for(i=0; i<len; i++){
            if(!iscntrl(buf[i])) putchar(buf[i]);   // Echo back message
            else putchar('.');
        }
        printf("\n");
    }
}
```

If len exceeds the length of the message, it will print out characters beyond what was read in.

```zsh
10
hello there
ECHO: |hello there|
25
hello
ECHO: |hello..there..y ...|
            -------------> leaked data
```

major Read overflow attack == __Heartbleed bug__

## Stale memory

* A __dangling pointer bug__ occurs when a pointer is freed, but the program continues to use it.
* An attacker can arrange for the freed memory to be reallocated under his control.

Example:

```C
struct foo { int (*cmp)(char*,char*); };

struct foo *p = malloc(...);
free(p);
...
q = malloc(...)             // Reuse memory
*q = 0xdeadbeef;            // Attacker control
...
p->cmp("hello","hello");    // Dangling pointer

```

This program reuses p by calling the compare function pointer. Now a dereference can do what the attacker wants.
